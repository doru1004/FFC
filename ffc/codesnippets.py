"Code snippets for code generation."

# Copyright (C) 2007-2013 Anders Logg
#
# This file is part of FFC.
#
# FFC is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# FFC is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with FFC. If not, see <http://www.gnu.org/licenses/>.
#
# Modified by Kristian B. Oelgaard 2010-2013
# Modified by Marie Rognes 2007-2012
# Modified by Peter Brune 2009
# Modified by Martin Alnaes, 2013
#
# First added:  2007-02-28
# Last changed: 2014-06-10

# Code snippets

from ufl import Cell, OuterProductCell

__all__ = ["comment_ufc", "comment_dolfin", "header_h", "header_c", "footer",
           "eval_basis_decl", "eval_basis_init", "eval_basis", "eval_basis_copy",
           "eval_derivs_decl", "eval_derivs_init", "eval_derivs", "eval_derivs_copy"]

__old__ = ["evaluate_f", "map_onto_physical", "fiat_coordinate_map",
           "transform_snippet", "combinations_snippet", "ip_coordinates",
           "reference_facet_to_cell_jacobian", "reference_normals"]

__all__ += __old__

comment_ufc = """\
// This code conforms with the UFC specification version %(ufc_version)s
// and was automatically generated by FFC version %(ffc_version)s.
"""

comment_dolfin = """\
// This code conforms with the UFC specification version %(ufc_version)s
// and was automatically generated by FFC version %(ffc_version)s.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
"""

# Code snippets for headers and footers

header_h = """\
#ifndef __%(prefix_upper)s_H
#define __%(prefix_upper)s_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>
"""

header_c = """\
#include "%(prefix)s.h"
"""

footer = """\
#endif
"""

# Code snippets storing reference facet -> reference cell Jacobians

_facet_to_cell_jacobian_interval = """\
// Jacobian of mapping from reference vertex to reference interval
double ref_facet_jac[2][1] = {{1.0}, {1.0}};
"""

_facet_to_cell_jacobian_triangle = """\
// Jacobian of mapping from reference interval to reference triangle
double ref_facet_jac[3][2] = {{-1.0, 1.0}, {0.0, 1.0}, {1.0, 0.0}};
"""

_facet_to_cell_jacobian_quad = """\
// Jacobian of mapping from reference interval to reference quad
double ref_facet_jac[4][2] = {{0.0, 1.0}, {0.0, 1.0}, {1.0, 0.0}, {1.0, 0.0}};
"""

_facet_to_cell_jacobian_tetrahedron = """\
// Jacobian of mapping from reference triangle to reference tetrahedron
double ref_facet_jac[4][6] = {{-1.0, -1.0, 1.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 1.0, 0.0, 0.0, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0}, {1.0, 0.0, 0.0, 1.0, 0.0, 0.0}};
"""

_facet_to_cell_jacobian_interval_x_interval = """\
// Jacobian of mapping from facet reference cell to reference facet of interval x interval
double ref_facet_jac[4][2] = {{1.0, 0.0}, {1.0, 0.0}, {0.0, 1.0}, {0.0, 1.0}};
"""

_facet_to_cell_jacobian_triangle_x_interval = """\
// Jacobian of mapping from facet reference cell to reference facet of triangle x interval
double ref_facet_jac[5][6] = {{1.0, 0.0, 0.0, 1.0, 0.0, 0.0}, {1.0, 0.0, 0.0, 1.0, 0.0, 0.0}, {-1.0, 0.0, 1.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 1.0, 0.0, 0.0, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
"""

_facet_to_cell_jacobian_quad_x_interval = """\
// Jacobian of mapping from facet reference cell to reference facet of quad x interval
double ref_facet_jac[6][6] = {{1.0, 0.0, 0.0, 1.0, 0.0, 0.0}, {1.0, 0.0, 0.0, 1.0, 0.0, 0.0}, {0.0, 0.0, 1.0, 0.0, 0.0, 1.0}, {0.0, 0.0, 1.0, 0.0, 0.0, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0}, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
"""

reference_facet_to_cell_jacobian = {
Cell("interval"): _facet_to_cell_jacobian_interval,
Cell("interval", 2): _facet_to_cell_jacobian_interval,
Cell("interval", 3): _facet_to_cell_jacobian_interval,
Cell("triangle"): _facet_to_cell_jacobian_triangle,
Cell("triangle", 3): _facet_to_cell_jacobian_triangle,
Cell("tetrahedron"): _facet_to_cell_jacobian_tetrahedron,
Cell("quadrilateral"): _facet_to_cell_jacobian_quad,
Cell("quadrilateral", 3): _facet_to_cell_jacobian_quad,
OuterProductCell(Cell("interval"), Cell("interval")): _facet_to_cell_jacobian_interval_x_interval,
OuterProductCell(Cell("interval", 2), Cell("interval")): _facet_to_cell_jacobian_interval_x_interval,
OuterProductCell(Cell("interval", 2), Cell("interval"), gdim=3): _facet_to_cell_jacobian_interval_x_interval,
OuterProductCell(Cell("interval", 3), Cell("interval")): _facet_to_cell_jacobian_interval_x_interval,
OuterProductCell(Cell("triangle"), Cell("interval")): _facet_to_cell_jacobian_triangle_x_interval,
OuterProductCell(Cell("triangle", 3), Cell("interval")): _facet_to_cell_jacobian_triangle_x_interval,
OuterProductCell(Cell("quadrilateral"), Cell("interval")): _facet_to_cell_jacobian_quad_x_interval,
OuterProductCell(Cell("quadrilateral", 3), Cell("interval")): _facet_to_cell_jacobian_quad_x_interval
}

# Code snippets storing facet orientations on reference element

_reference_normals_interval = """\
// Reference normals on reference interval
double ref_norms[2][1] = {{-1.0}, {1.0}};
"""

_reference_normals_triangle = """\
// Reference normals on reference triangle
double ref_norms[3][2] = {{1.0, 1.0}, {-1.0, 0.0}, {0.0, -1.0}};
"""

_reference_normals_quad = """\
// Reference normals on reference quad
double ref_norms[4][2] = {{-1.0, 0.0}, {1.0, 0.0}, {0.0, -1.0}, {0.0, 1.0}};
"""

_reference_normals_tetrahedron = """\
// Reference normals on reference tetrahedron
double ref_norms[4][3] = {{1.0, 1.0, 1.0}, {-1.0, 0.0, 0.0}, {0.0, -1.0, 0.0}, {0.0, 0.0, -1.0}};
"""

_reference_normals_interval_x_interval = """\
// Reference normals on reference interval x interval
double ref_norms[4][2] = {{0.0, -1.0}, {0.0, 1.0}, {-1.0, 0.0}, {1.0, 0.0}};
"""

_reference_normals_triangle_x_interval = """\
// Reference normals on reference tetrahedron
double ref_norms[5][3] = {{0.0, 0.0, -1.0}, {0.0, 0.0, 1.0}, {1.0, 1.0, 0.0}, {-1.0, 0.0, 0.0}, {0.0, -1.0, 0.0}};
"""

_reference_normals_quad_x_interval = """\
// Reference normals on reference tetrahedron
double ref_norms[6][3] = {{0.0, 0.0, -1.0}, {0.0, 0.0, 1.0}, {-1.0, 0.0, 0.0}, {1.0, 0.0, 0.0}, {0.0, -1.0, 0.0}, {0.0, 1.0, 0.0}};
"""

reference_normals = {
Cell("interval"): _reference_normals_interval,
Cell("interval", 2): _reference_normals_interval,
Cell("interval", 3): _reference_normals_interval,
Cell("triangle"): _reference_normals_triangle,
Cell("triangle", 3): _reference_normals_triangle,
Cell("tetrahedron"): _reference_normals_tetrahedron,
Cell("quadrilateral"): _reference_normals_quad,
Cell("quadrilateral", 3): _reference_normals_quad,
OuterProductCell(Cell("interval"), Cell("interval")): _reference_normals_interval_x_interval,
OuterProductCell(Cell("interval", 2), Cell("interval")): _reference_normals_interval_x_interval,
OuterProductCell(Cell("interval", 2), Cell("interval"), gdim=3): _reference_normals_interval_x_interval,
OuterProductCell(Cell("interval", 3), Cell("interval")): _reference_normals_interval_x_interval,
OuterProductCell(Cell("triangle"), Cell("interval")): _reference_normals_triangle_x_interval,
OuterProductCell(Cell("triangle", 3), Cell("interval")): _reference_normals_triangle_x_interval,
OuterProductCell(Cell("quadrilateral"), Cell("interval")): _reference_normals_quad_x_interval,
OuterProductCell(Cell("quadrilateral", 3), Cell("interval")): _reference_normals_quad_x_interval
}

# No idea what this is

evaluate_f = "f.evaluate(vals, y, c);"

evaluate_basis_dofmap = """\
unsigned int element = 0;
unsigned int tmp = 0;
for (unsigned int j = 0; j < %d; j++)
{
  if (tmp +  dofs_per_element[j] > i)
  {
    i -= tmp;
    element = element_types[j];
    break;
  }
  else
    tmp += dofs_per_element[j];
}"""

# FIXME: This is dead slow because of all the new calls
# Used in evaluate_basis_derivatives. For second order derivatives in 2D it will
# generate the combinations: [(0, 0), (0, 1), (1, 0), (1, 1)] (i.e., xx, xy, yx, yy)
# which will also be the ordering of derivatives in the return value.
combinations_snippet = """\
// Declare two dimensional array that holds combinations of derivatives and initialise
unsigned int %(combinations)s[%(max_num_derivatives)s][%(max_degree)s];
for (unsigned int row = 0; row < %(max_num_derivatives)s; row++)
{
  for (unsigned int col = 0; col < %(max_degree)s; col++)
    %(combinations)s[row][col] = 0;
}

// Generate combinations of derivatives
for (unsigned int row = 1; row < %(num_derivatives)s; row++)
{
  for (unsigned int num = 0; num < row; num++)
  {
    for (unsigned int col = %(n)s-1; col+1 > 0; col--)
    {
      if (%(combinations)s[row][col] + 1 > %(dimension-1)s)
        %(combinations)s[row][col] = 0;
      else
      {
        %(combinations)s[row][col] += 1;
        break;
      }
    }
  }
}"""

def _transform_snippet(tdim, gdim):

    if tdim == gdim:
        _t = ""
        _g = ""
    else:
        _t = "_t"
        _g = "_g"

    # Matricize K_ij -> {K_ij}
    matrix = "{{" + "}, {".join([", ".join(["K[%d]" % (t*gdim + g)
                                            for g in range(gdim)])
                                 for t in range(tdim)]) + "}};\n\n"
    snippet = """\
// Compute inverse of Jacobian
const double %%(K)s[%d][%d] = %s""" % (tdim, gdim, matrix)

    snippet +="""// Declare transformation matrix
// Declare pointer to two dimensional array and initialise
double %%(transform)s[%%(max_g_deriv)s][%%(max_t_deriv)s];
for (unsigned int j = 0; j < %%(num_derivatives)s%(g)s; j++)
{
  for (unsigned int k = 0; k < %%(num_derivatives)s%(t)s; k++)
    %%(transform)s[j][k] = 1;
}

// Construct transformation matrix
for (unsigned int row = 0; row < %%(num_derivatives)s%(g)s; row++)
{
  for (unsigned int col = 0; col < %%(num_derivatives)s%(t)s; col++)
  {
    for (unsigned int k = 0; k < %%(n)s; k++)
      %%(transform)s[row][col] *= %%(K)s[%%(combinations)s%(t)s[col][k]][%%(combinations)s%(g)s[row][k]];
  }
}""" % {"t":_t, "g":_g}

    return snippet

# Codesnippets used in evaluate_dof
_map_onto_physical_1D = """\
// Evaluate basis functions for affine mapping
const double w0 = 1.0 - X_%(i)d[%(j)s][0];
const double w1 = X_%(i)d[%(j)s][0];

// Compute affine mapping y = F(X)
y[0] = w0*vertex_coordinates[0] + w1*vertex_coordinates[1];"""

_map_onto_physical_2D = """\
// Evaluate basis functions for affine mapping
const double w0 = 1.0 - X_%(i)d[%(j)s][0] - X_%(i)d[%(j)s][1];
const double w1 = X_%(i)d[%(j)s][0];
const double w2 = X_%(i)d[%(j)s][1];

// Compute affine mapping y = F(X)
y[0] = w0*vertex_coordinates[0] + w1*vertex_coordinates[2] + w2*vertex_coordinates[4];
y[1] = w0*vertex_coordinates[1] + w1*vertex_coordinates[3] + w2*vertex_coordinates[5];"""

_map_onto_physical_2D_1D = """\
// Evaluate basis functions for affine mapping
const double w0 = 1.0 - X_%(i)d[%(j)s][0];
const double w1 = X_%(i)d[%(j)s][0];

// Compute affine mapping y = F(X)
y[0] = w0*vertex_coordinates[0] + w1*vertex_coordinates[2];
y[1] = w0*vertex_coordinates[1] + w1*vertex_coordinates[3];"""

_map_onto_physical_3D = """\
// Evaluate basis functions for affine mapping
const double w0 = 1.0 - X_%(i)d[%(j)s][0] - X_%(i)d[%(j)s][1] - X_%(i)d[%(j)s][2];
const double w1 = X_%(i)d[%(j)s][0];
const double w2 = X_%(i)d[%(j)s][1];
const double w3 = X_%(i)d[%(j)s][2];

// Compute affine mapping y = F(X)
y[0] = w0*vertex_coordinates[0] + w1*vertex_coordinates[3] + w2*vertex_coordinates[6] + w3*vertex_coordinates[9];
y[1] = w0*vertex_coordinates[1] + w1*vertex_coordinates[4] + w2*vertex_coordinates[7] + w3*vertex_coordinates[10];
y[2] = w0*vertex_coordinates[2] + w1*vertex_coordinates[5] + w2*vertex_coordinates[8] + w3*vertex_coordinates[11];"""

_map_onto_physical_3D_1D = """\
// Evaluate basis functions for affine mapping
const double w0 = 1.0 - X_%(i)d[%(j)s][0];
const double w1 = X_%(i)d[%(j)s][0];

// Compute affine mapping y = F(X)
y[0] = w0*vertex_coordinates[0] + w1*vertex_coordinates[3];
y[1] = w0*vertex_coordinates[1] + w1*vertex_coordinates[4];
y[2] = w0*vertex_coordinates[2] + w1*vertex_coordinates[5];"""

_map_onto_physical_3D_2D = """\
// Evaluate basis functions for affine mapping
const double w0 = 1.0 - X_%(i)d[%(j)s][0] - X_%(i)d[%(j)s][1];
const double w1 = X_%(i)d[%(j)s][0];
const double w2 = X_%(i)d[%(j)s][1];

// Compute affine mapping y = F(X)
y[0] = w0*vertex_coordinates[0] + w1*vertex_coordinates[3] + w2*vertex_coordinates[6];
y[1] = w0*vertex_coordinates[1] + w1*vertex_coordinates[4] + w2*vertex_coordinates[7];
y[2] = w0*vertex_coordinates[2] + w1*vertex_coordinates[5] + w2*vertex_coordinates[8];
"""

_ip_coordinates_1D = """\
X%(num_ip)d[0] = %(name)s[%(ip)s][0]*vertex_coordinates%(restriction)s[0] + \
                 %(name)s[%(ip)s][1]*vertex_coordinates%(restriction)s[1];"""

_ip_coordinates_2D = """\
X%(num_ip)d[0] = %(name)s[%(ip)s][0]*vertex_coordinates%(restriction)s[0] + \
                 %(name)s[%(ip)s][1]*vertex_coordinates%(restriction)s[2] + %(name)s[%(ip)s][2]*vertex_coordinates%(restriction)s[4];
X%(num_ip)d[1] = %(name)s[%(ip)s][0]*vertex_coordinates%(restriction)s[1] + \
                 %(name)s[%(ip)s][1]*vertex_coordinates%(restriction)s[3] + %(name)s[%(ip)s][2]*vertex_coordinates%(restriction)s[5];"""

_ip_coordinates_3D = """\
X%(num_ip)d[0] = %(name)s[%(ip)s][0]*vertex_coordinates%(restriction)s[0] + \
                 %(name)s[%(ip)s][1]*vertex_coordinates%(restriction)s[3] + \
                 %(name)s[%(ip)s][2]*vertex_coordinates%(restriction)s[6] + \
                 %(name)s[%(ip)s][3]*vertex_coordinates%(restriction)s[9];
X%(num_ip)d[1] = %(name)s[%(ip)s][0]*vertex_coordinates%(restriction)s[1] + \
                 %(name)s[%(ip)s][1]*vertex_coordinates%(restriction)s[4] + \
                 %(name)s[%(ip)s][2]*vertex_coordinates%(restriction)s[7] + \
                 %(name)s[%(ip)s][3]*vertex_coordinates%(restriction)s[10];
X%(num_ip)d[2] = %(name)s[%(ip)s][0]*vertex_coordinates%(restriction)s[2] + \
                 %(name)s[%(ip)s][1]*vertex_coordinates%(restriction)s[5] + \
                 %(name)s[%(ip)s][2]*vertex_coordinates%(restriction)s[8] + \
                 %(name)s[%(ip)s][3]*vertex_coordinates%(restriction)s[11];"""

# Codesnippets used in evaluatebasis[|derivatives]
_map_coordinates_FIAT_interval = """\
// Get coordinates and map to the reference (FIAT) element
double X = (2.0*x[0] - vertex_coordinates[0] - vertex_coordinates[1]) / J[0];"""

_map_coordinates_FIAT_interval_in_2D = """\
// Get coordinates and map to the reference (FIAT) element
double X = 2*(std::sqrt(std::pow(x[0] - vertex_coordinates[0], 2) + std::pow(x[1] - vertex_coordinates[1], 2)) / detJ) - 1.0;"""

_map_coordinates_FIAT_interval_in_3D = """\
// Get coordinates and map to the reference (FIAT) element
double X = 2*(std::sqrt(std::pow(x[0] - vertex_coordinates[0], 2) + std::pow(x[1] - vertex_coordinates[1], 2) + std::pow(x[2] - vertex_coordinates[2], 2))/ detJ) - 1.0;"""

_map_coordinates_FIAT_triangle = """\
// Compute constants
const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
const double C1 = vertex_coordinates[3] + vertex_coordinates[5];

// Get coordinates and map to the reference (FIAT) element
double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;"""

_map_coordinates_FIAT_triangle_in_3D = """\
const double b0 = vertex_coordinates[0];
const double b1 = vertex_coordinates[1];
const double b2 = vertex_coordinates[2];

// P_FFC = J^dag (p - b), P_FIAT = 2*P_FFC - (1, 1)
double X = 2*(K[0]*(x[0] - b0) + K[1]*(x[1] - b1) + K[2]*(x[2] - b2)) - 1.0;
double Y = 2*(K[3]*(x[0] - b0) + K[4]*(x[1] - b1) + K[5]*(x[2] - b2)) - 1.0;
"""

_map_coordinates_FIAT_tetrahedron = """\
// Compute constants
const double C0 = vertex_coordinates[9]  + vertex_coordinates[6] + vertex_coordinates[3]  - vertex_coordinates[0];
const double C1 = vertex_coordinates[10] + vertex_coordinates[7] + vertex_coordinates[4]  - vertex_coordinates[1];
const double C2 = vertex_coordinates[11] + vertex_coordinates[8] + vertex_coordinates[5]  - vertex_coordinates[2];

// Compute subdeterminants
const double d_00 = J[4]*J[8] - J[5]*J[7];
const double d_01 = J[5]*J[6] - J[3]*J[8];
const double d_02 = J[3]*J[7] - J[4]*J[6];
const double d_10 = J[2]*J[7] - J[1]*J[8];
const double d_11 = J[0]*J[8] - J[2]*J[6];
const double d_12 = J[1]*J[6] - J[0]*J[7];
const double d_20 = J[1]*J[5] - J[2]*J[4];
const double d_21 = J[2]*J[3] - J[0]*J[5];
const double d_22 = J[0]*J[4] - J[1]*J[3];

// Get coordinates and map to the reference (FIAT) element
double X = (d_00*(2.0*x[0] - C0) + d_10*(2.0*x[1] - C1) + d_20*(2.0*x[2] - C2)) / detJ;
double Y = (d_01*(2.0*x[0] - C0) + d_11*(2.0*x[1] - C1) + d_21*(2.0*x[2] - C2)) / detJ;
double Z = (d_02*(2.0*x[0] - C0) + d_12*(2.0*x[1] - C1) + d_22*(2.0*x[2] - C2)) / detJ;
"""

# Mappings to code snippets used by format These dictionaries accept
# as keys: first the topological dimension, and second the geometric
# dimension

# Geometry related snippets
map_onto_physical = {1: {1: _map_onto_physical_1D,
                         2: _map_onto_physical_2D_1D,
                         3: _map_onto_physical_3D_1D},
                     2: {2: _map_onto_physical_2D,
                         3: _map_onto_physical_3D_2D},
                     3: {3: _map_onto_physical_3D}}

fiat_coordinate_map = {"interval": {1:_map_coordinates_FIAT_interval,
                                    2:_map_coordinates_FIAT_interval_in_2D,
                                    3:_map_coordinates_FIAT_interval_in_3D},
                       "triangle": {2:_map_coordinates_FIAT_triangle,
                                    3: _map_coordinates_FIAT_triangle_in_3D},
                       "tetrahedron": {3:_map_coordinates_FIAT_tetrahedron}}

transform_snippet = {"interval": {1: _transform_snippet(1, 1),
                                  2: _transform_snippet(1, 2),
                                  3: _transform_snippet(1, 3)},
                     "triangle": {2: _transform_snippet(2, 2),
                                  3: _transform_snippet(2, 3)},
                     "tetrahedron": {3: _transform_snippet(3, 3)}}

ip_coordinates = {1: (3, _ip_coordinates_1D),
                  2: (10, _ip_coordinates_2D),
                  3: (21, _ip_coordinates_3D)}

# Code snippets for runtime quadrature (calling evaluate_basis)

eval_basis_decl = """\
std::vector<std::vector<double> > %(table_name)s(num_quadrature_points);"""

eval_basis_init = """\
for (std::size_t ip = 0; ip < num_quadrature_points; ip++)
  %(table_name)s[ip].resize(%(table_size)s);"""

eval_basis = """\
// Get current quadrature point and compute values of basis functions
const double* x = quadrature_points + ip*%(gdim)s;
const double* v = vertex_coordinates + %(vertex_offset)s;
%(form_prefix)s_finite_element_%(element_number)s::_evaluate_basis_all(%(eval_name)s, x, v, cell_orientation);"""

eval_basis_copy = """\
// Copy values to table %(table_name)s
for (std::size_t i = 0; i < %(space_dim)s; i++)
  %(table_name)s[ip][%(table_offset)s + i] = %(eval_name)s[%(eval_stride)s*i + %(eval_offset)s];"""

eval_derivs_decl = """\
std::vector<std::vector<double> > %(table_name)s(num_quadrature_points);"""

eval_derivs_init = """\
for (std::size_t ip = 0; ip < num_quadrature_points; ip++)
  %(table_name)s[ip].resize(%(table_size)s);"""

eval_derivs = """\
// Get current quadrature point and compute values of basis function derivatives
const double* x = quadrature_points + ip*%(gdim)s;
const double* v = vertex_coordinates + %(vertex_offset)s;
%(form_prefix)s_finite_element_%(element_number)s::_evaluate_basis_derivatives_all(%(n)s, %(eval_name)s, x, v, cell_orientation);"""

eval_derivs_copy = """\
// Copy values to table %(table_name)s
for (std::size_t i = 0; i < %(space_dim)s; i++)
  %(table_name)s[ip][%(table_offset)s + i] = %(eval_name)s[%(eval_stride)s*i + %(eval_offset)s];"""
